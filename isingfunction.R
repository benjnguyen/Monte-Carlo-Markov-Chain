
# Set seed for reproducible randomization
set.seed(42)

# Create lattice with specified number of rows and columns
getConfig <- function(nrow, ncol, statespace = c(-1, 1))
{
  config <- sample(x = statespace, size = nrow*ncol, replace = TRUE)
  config <- matrix(config, nrow = nrow, byrow = TRUE)
  return(config)
}

# Initialize the lattice
mat <- getConfig(100, 100)

# Specify the number of MCMC steps
nsims <-  3*10^7

# Pre-select sampled positions to be used in the algorithm
# The purpose of this is to speed up the algorithm by using pre-selected positions
# so that we do not have to do it during the algorithm
vec <- list()
xvec <- sample(1:nrow(mat), nsims, TRUE); xvec <- matrix(xvec, nrow = nsims, byrow = T)
yvec <- sample(1:ncol(mat), nsims, TRUE); yvec <- matrix(yvec, nrow = nsims, byrow = T)
vec <- cbind(xvec, yvec)

# Discover neighboring sites given the pre-selected positions
# Generates a matrix of neighboring positions given that the lattice is torus shaped (wraps around)
xright <- vec[ ,1]%%nrow(mat)+1; xright <- matrix(xright, nrow = nsims, byrow = T)
xleft <- (vec[ ,1]+nrow(mat)-2)%%nrow(mat) + 1;  xleft <- matrix(xleft, nrow = nsims, byrow = T)
yup <- (vec[, 2]+ncol(mat)-2)%%ncol(mat) + 1;  yup <- matrix(yup, nrow = nsims, byrow = T)
ydown <- (vec[, 2]%%ncol(mat)) + 1;  ydown <- matrix(ydown, nrow = nsims, byrow = T)
nb <- cbind(xright, xleft, yup, ydown)

# Main function
# MCMC Ising Model
sim <- function(mat, nsims, temp, vec, nb)
{
  # Create initial start time to find run-time
  Sys.time() -> start
  # Define parameters for the algorithm
  beta <- 1/temp
  accept <- 0
  sweepvec <- c(1:nsims)
  nrow <- nrow(mat)
  ncol <- ncol(mat)
  N <- nrow*ncol
  magnetization <- c(1:nsims)
  # Create list that stores information on the lattice
  saveMC <- list()
  saveMC[[1]] <- mat
  saveAccept <- rep(list(0), nsims)
  # Run the simulation
  for(i in 1:nsims)
  {
    x <- vec[i, 1]
    y <- vec[i, 2]
    right <- nb[i,1]
    left <- nb[i,2]
    up <- nb[i,3]
    down <- nb[i,4]
    neighbors <- mat[left, y] + mat[right, y] + mat[x, up] + mat[x, down]
    # Compute energy for lattice and proposal lattice
    E_old <- -mat[x, y] * neighbors
    E_new <- mat[x,y] * neighbors
    boltzman <- exp(-beta*(E_new - E_old))
    boolaccept <- FALSE
    # If energy is not decreased, accept proposal w.p. boltz > runif(1)
    if (boltzman > runif(1))
    {
      mat[x, y] <- -mat[x,y]
      accept <- accept + 1
      boolaccept <- TRUE
    }
    if (boolaccept == TRUE)
    {
      saveAccept[[i]] <- 1
    }
    magnetization[i] <- (1/N)*sum(mat)
    # Save lattice every 10000 MCMC steps
    # Could pass this in as a parameter in the function
    if (i%%10000 == 0) 
    {
      #print(i)
      saveMC <- append(saveMC, list(mat))
    }
  }
  # Finish run-time and compute run-time
  Sys.time() -> end
  # Output information generated by the algorithm
  cat("Number of Plots Saved:", length(saveMC), "\n")
  cat("Time:", end - start, "\n")
  cat("Acceptance rate:", accept/nsims, "\n")
  cat("Final Magnetization:", magnetization[nsims], "\n")
  #plot(sweepvec, magnetization)
  return(list(intermediate = saveMC,
              mat = mat,
              time = sweepvec,
              magnet = magnetization,
              accepts = simplify2array(tail(saveAccept, 100))))
}

#####################
# Making the movie
#####################
library(lattice) # heatmap package
library(animation)

# Generate 3 simulations
# Simulation 'a' with temperature 0.5
# Simulation 'b' with temperature 2.26
# Simulation 'c' with temperature 10
a <- sim(mat, nsims, temp = 0.5, vec, nb) # Expect homogenous
b <- sim(mat, nsims, temp = 2.26, vec, nb) # Expect clusters
c <- sim(mat, nsims, temp = 10, vec, nb)   # Expect random noise


# Make .gif of lattice over time
# Make sure iterations coincides with choice of number
# that was used to specify when the lattice is saved into memory.
saveGIF({
  for(i in seq(1,length(a$intermediate),6))
  {
    if (i == 1)
    {
      l <- levelplot(a$intermediate[[i]], 
                     col.regions= colorRampPalette(c("red4","blue4")),
                     colorkey = FALSE,
                     xlab = "",
                     ylab = "",
                     main = paste("Temperature: 0.5"),
                     sub = paste("Current iteration:", i))
      plot(l)
    }
    l <- levelplot(a$intermediate[[i]], 
                   col.regions= colorRampPalette(c("red4","blue4")),
                   colorkey = FALSE,
                   xlab = "",
                   ylab = "",
                   main = paste("Temperature: 0.5"),
                   sub = paste("Current iteration:", i*10000))
    plot(l, main = paste("Current iteration:", i*10000))
  }
}, interval=0.2, movie.name="anima1.gif")


